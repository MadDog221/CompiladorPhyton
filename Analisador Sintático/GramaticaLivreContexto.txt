Gramática Livre de Contexto padronizada, fatorada, sem recursão à esquerda, sem produções unitárias e vazias e na forma de Backus-Naur (BNF) 

P(1) <start> := <registro_declaracao><constantes_declaracao><variaveis_declaracao><funcao_declaracao><algoritmo_declaracao>

P(2) <registro_declaracao> := registro token_identificador { <declaracao_reg> }
P(3) 				     | Ɛ

P(4) <declaracao_reg> := <declaracao>; <declaracao_reg> 
P(5)				| Ɛ

P(6) <declaracao> := <tipo_primitivo> token_identificador

P(7) <tipo_primitivo> := cadeia 
P(8)			| real 
P(9)			| inteiro 
P(10)			| char 
P(11)			| booleano

P(12) <constantes_declaracao> := constantes { <declaracao_const>  }

P(13) <declaracao_const> := <declaracao> = <valor_primitivo>;  <declaracao_const> 
P(14)				| Ɛ

P(15) <valor_primitivo> := token_cadeia 
P(16)		| token_real 
P(17)		| token_inteiro 
P(18)		| token_char 
P(19)		| verdadeiro 
P(20)		| falso

P(21) <variaveis_declaracao> := variaveis { <declaracao_var> }

P(22) <declaracao_var> := <declaracao> <decl_var_deriva> 
P(23)				| registro token_identificador<identificador_deriva>; <declaracao_var> 
P(24)				| Ɛ

P(25) <decl_var_deriva> := <inicializacao>;<declaracao_var>
 
P(26) <inicializacao> := = <valor_primitivo> 
P(27)			      | Ɛ

P(28) <funcao_declaracao> := funcao <funcao_deriva>
P(29)				      | Ɛ

P(30) <funcao_deriva> := <tipo_return> token_identificador <deriva_param>  { <deriva_cont_funcao>  } <funcao_deriva_fat>  
P(31)			         | Ɛ

P(32) <deriva_param> := <tipo_param> token_identificador <param_deriva> 
P(33)			        | Ɛ

P(34) <funcao_deriva_fat> := <funcao_deriva> 
P(35)				| Ɛ

P(36) <deriva_cont_funcao> := <declaracao_var> <comandos> retorno <return_deriva> 
P(37)				      | <comandos> retorno <return_deriva>

P(38) <tipo_return> := <tipo_primitivo> 
P(39)			| registro 
P(40)			| vazio

P(41) <tipo_param> := <tipo_primitivo> 
P(42)			| registro 
P(43)			| Ɛ

P(44) <return_deriva> := vazio; 
P(45)			| token_identificador; 
P(46)			| <valor_primitivo>

P(47) <algoritmo_declaracao> :=  algoritmo {<deriva_cont_meth> }

P(48) <comandos> := <se_declaracao> 
P(49)			| <enquanto_declaracao> 
P(50)			| <para_declaracao> 
P(51)			| <escreva_declaracao> 
P(52)			| <leia_declaracao> 
P(53)			| Ɛ

P(54) <se_declaracao> := se <exp_rel_bol> {<comandos>}<senao_decl>

P(55) <senao_decl> := senão {<comandos>} 
P(56)			| Ɛ
	
P(57) <enquanto_declaracao> := enquanto <exp_rel_bol> { <comandos> }

P(58) <para_declaracao> := para token_identificador = token_inteiro; token_identificador <op_relacional> token_inteiro; token_identificador <op_cont>; {<comandos>}

P(59) <escreva_declaracao> := escreva (<exp_escreva>);

P(60) <exp_escreva> := <exp_imprime><exp_escreva_deriva><exp_escreva> 
P(61)			| Ɛ

P(62) <exp_escreva_deriva> := ,<exp_imprime> 
P(63)				| Ɛ

P(64) <exp_imprime> := token_cadeia 
P(65)			| token_char 
P(66)			| token_identificador<identificador_deriva> 
P(67)			| (<exp_simples>)

P(68) <identificador_deriva> := [token_inteiro]<matriz> 
P(69)				| .token_identificador = <valor_primitivo> 
P(70)				| Ɛ 

P(71) <matriz> := [token_inteiro]
	
P(72) <leia_declaracao> := escreva (<exp_leia>);

P(73) <exp_leia> := <exp_armazena><exp_leia_deriva><exp_leia> 
P(74)		| Ɛ

P(75) <exp_leia_deriva> := ,<exp_armazena> 
P(76)			| Ɛ

P(77) <exp_armazena> := token_identificador<identificador_deriva>
	
P(78) <exp_rel_bol> := <exp_simples> <op_relacional> <exp_simples> <exp_rel_deriva>

P(79) <exp_rel_deriva> := <op_bolleano> <exp_simples> <op_relacional> <exp_simples> <exp_rel_deriva> 
P(80)			| Ɛ

P(81) <op_relacional> := <<op_rel_deriva> 
P(82)			| > <op_rel_deriva>
P(83)			| == 
P(84)			| !=

P(85) <op_rel_deriva> := = 
P(86): 			| Ɛ

P(87) <op_bolleano> := && 
P(88)			| ||
	
P(89) <exp_aritmetica> := token_identificador = <exp_simples>

P(90) <exp_simples> := <op_ss><termo><termo_deriva> 
P(91)			| <termo><termo_deriva>

P(92) <termo_deriva> := +<op_soma_deriva>
P(93)			| -<op_sub_deriva> 
P(94)			| Ɛ

P(95) <op_soma_deriva> := <termo><termo_deriva> 
P(96)			| +

P(97) <op_sub_deriva> := <termo><termo_deriva> 
P(98)			| -

P(99) <op_ss> := + 
P(100)		| -

P(101) <op_cont> := ++ 
P(102)		| --

P(103) <termo> := <fator><fator_deriva>
	
P(104) <fator_deriva> := <op_md><fator><fator_deriva> 
P(105)			| Ɛ

P(106) <op_md> := * 
P(107)		| /

P(108) <fator> := token_identificador<identificador_deriva> 
P(109)		| token_inteiro 
